[globalOptions]

# Set the input directory map in an absolute path. 
# - The input forcing and parameter directories will be relative to this.
inputDir = /gpfs/work4/0/dynql/input/

# Set the output directory in an absolute path.
outputDir = /gpfs/scratch1/shared/dynql/test_offline_calcLoads_v1/

#Global Run
#cloneAreas = Global

# Map of clone (must be provided in PCRaster maps)
# - spatial resolution and coverage are based on this map:
cloneMap = clone_maps/RhineMeuse_05min.map
#cloneMap = clone_maps/clone_%3s.map

# The area/ landmask of interest:
# If None, area/landmask is limited for cells with ldd value.
#~ None
landmask = clone_maps/RhineMeuse_05min.map
#landmask = clone_maps/mask_%3s.map

# netcdf attributes for output files:
institution = Utrecht University
title       = PCR-GLOBWB output
description = Edward Jones

startTime = 2005-01-01
endTime   = 2007-12-31
# Format: YYYY-MM-DD
# The model runs on the daily time step.

# spinning up options
maxSpinUpsInYears = 1
minConvForTotlSto = 0.5
minConvForSoilSto = 0.5
minConvForGwatSto = 0.5
minConvForChanSto = 0.5

# an optional option to include the merging process (needed for parallel runs with/without modflow)
# - for parallel runs with spin-ups, we should set this to False
with_merging = False

[globalMergingAndModflowOptions]
# the global clone map
#cloneMap = None

# The area/landmask of interest:
#landmask = None
# If None, area/landmask is limited for cells with ldd value.

# option to indicate if an online coupling between PCR-GLOBWB and MODFLOW models used
online_coupling_between_pcrglobwb_and_modflow = False

[meteoOptions]

# Set the forcing temperature and precipitation files (relative to inputDir)
precipitationNC = forcing/future/CMIP6/GFDL/gfdl-esm4_w5e5_historical_pr_global_daily_1850_2014_mday-1.nc
temperatureNC   = forcing/future/CMIP6/GFDL/gfdl-esm4_w5e5_historical_tas_global_daily_1850_2014_C.nc
precipitationVarName = pr
precipitationCorrectionFactor=1

temperatureVarName = tas

# Method to calculate referencePotETP (reference potential evaporation+transpiration)
referenceETPotMethod = Input
# options are "Hamon" and "Input" ; If "Input", the netcdf input file must be given:
refETPotFileNC = forcing/future/CMIP6/GFDL/gfdl-esm4_w5e5_historical_pet_global_daily_1979_2014_mday-1.nc

referenceETPotVarName = reference_potential_evaporation

# Set the forcing cloudcover, radiation and vapor pressure files (relative to inputDir), needed for water temperature module
cloudcoverNC = forcing/historical/cru_ts3.21.cld.dat.nc
radiationNC   =  forcing/future/CMIP6/GFDL/gfdl-esm4_w5e5_historical_rsds_global_daily_1850_2014_wm-2.nc
vaporNC   = forcing/historical/cru_ts3.21.vap.dat.nc
annualAvgTNC   =  forcing/future/CMIP6/GFDL/gfdl-esm4_w5e5_historical_tas_global_annAvg_1850_2014_C.nc
sunhoursTable = forcing/historical/sunhoursfrac.tbl

[meteoDownscalingOptions]
# This section is for a 5 arcmin run, for downscaling meteorological forcing at 30 arcmin to 5 arcmin.  
                                                                                                                                  
downscalePrecipitation  = False          
downscaleTemperature    = True          
downscaleReferenceETPot = False                                                                                                                   

# downscaling (based on the digital elevation model):                                                                                                            
# The downscaling will be performed by providing the "cellIds" (meteoDownscaleIds) of lower resolution cells.                                                    
meteoDownscaleIds = forcing/other/uniqueIds_30min.nc                            
highResolutionDEM = forcing/other/gtopo05min.nc

# lapse rates:                                                                                                                                                   
temperLapseRateNC = forcing/other/temperature_slope.nc
precipLapseRateNC = forcing/other/precipitation_slope.nc                                                                                                                                                   
# downscaling criteria (TODO: remove these):                                                                                                                     
temperatCorrelNC  = forcing/other/temperature_correl.nc
precipitCorrelNC  = forcing/other/precipitation_correl.nc
                                         
# windows length (unit: arc-degree) for smoothing/averaging forcing data (not recommended):                                                                      
smoothingWindowsLength = 0

[landSurfaceOptions]
debugWaterBalance = True

numberOfUpperSoilLayers = 2

topographyNC      = landSurface/topography_parameters_05min.nc
soilPropertiesNC  = landSurface/soilProperties5ArcMin.nc

includeIrrigation = True
# if True, there are four land cover types defined: forest,grassland,irrPaddy,irrNonPaddy
# if False, two (natural) land cover types defined: forest,grassland

# netcdf time series for historical expansion of irrigation areas (unit: hectares). 
# Note: The resolution of this map must be consisten with the resolution of cellArea. 
#~ historicalIrrigationArea = None
historicalIrrigationArea = waterUse/irrigationArea05ArcMin.nc
#irrigationEfficiency     = None

includeDomesticWaterDemand = True
includeIndustryWaterDemand = True
includeLivestockWaterDemand = True

domesticWaterDemandFile  = waterUse/domestic_water_demand_1961_to_2014_in_m_per_day_05arcmin.nc
industryWaterDemandFile  = waterUse/industrial_water_demand_1961_to_2014_in_m_per_day_05arcmin.nc
livestockWaterDemandFile = waterUse/livestock_water_demand_1961_to_2014_in_m_per_day_05arcmin.nc

# desalination water supply (maximum/potential/capacity)
desalinationWater = waterUse/desalination_water_version_april_2015.nc
limitAbstraction = False

# zone IDs (scale) at which ground- surface-water allocation is performed  
allocationSegmentsForGroundSurfaceWater = None
#allocationSegmentsForGroundSurfaceWater = waterUse/abstraction_zones_30min_05min.nc

# pcraster maps defining the partitioning of groundwater - surface water source 
#
# - predefined surface water - groundwater partitioning for irrigation demand (e.g. based on Siebert, Global Map of Irrigation Areas version 5)
#irrigationSurfaceWaterAbstractionFractionData           = waterUse/AEI_SWFRAC.nc
# -- quality map
#irrigationSurfaceWaterAbstractionFractionDataQuality    =waterUse/AEI_QUAL.nc
#
# - threshold values defining the preference for surface water source for irrigation purpose
# -- treshold to maximize surface water irrigation use (cells with irrSurfaceWaterAbstractionFraction above this will prioritize irrigation surface water use)
#treshold_to_maximize_irrigation_surface_water           = 0.50
# -- treshold to minimize fossil water withdrawal for irrigation (cells with irrSurfaceWaterAbstractionFraction below this have no fossil withdrawal for irrigation)
#treshold_to_minimize_fossil_groundwater_irrigation      = 0.70
#
# - predefined surface water - groundwater partitioning for non irrigation demand (e.g. based on McDonald, 2014)
#maximumNonIrrigationSurfaceWaterAbstractionFractionData = TODO


[forestOptions]
name = forest
debugWaterBalance = True

# snow module properties
snowModuleType      =  Simple
freezingT           = -0.0
degreeDayFactor     =  0.0025
snowWaterHoldingCap =  0.1
refreezingCoeff     =  0.05

# other paramater values
minTopWaterLayer = 0.0
minCropKC        = 0.2
minInterceptCap  = 0.0002

landCoverMapsNC = None 
# If NC file is not provided, we have to provide the following pcraster maps:
fracVegCover      = landSurface/landCover/naturalTall/vegf_tall.nc
minSoilDepthFrac  = landSurface/landCover/naturalTall/minf_tall_permafrost.nc
maxSoilDepthFrac  = landSurface/landCover/naturalTall/maxf_tall.nc
rootFraction1     = landSurface/landCover/naturalTall/rfrac1_tall.nc
rootFraction2     = landSurface/landCover/naturalTall/rfrac2_tall.nc	
maxRootDepth      = 1.0

# Parameters for the Arno's scheme:
arnoBeta = None
# If arnoBeta is defined, the soil water capacity distribution is based on this.
# If arnoBeta is NOT defined, maxSoilDepthFrac must be defined such that arnoBeta will be calculated based on maxSoilDepthFrac and minSoilDepthFrac.

cropCoefficientNC = landSurface/landCover/naturalTall/cropCoefficientForest.nc
interceptCapNC    = landSurface/landCover/naturalTall/interceptCapInputForest.nc
coverFractionNC   = landSurface/landCover/naturalTall/coverFractionInputForest.nc

# initial conditions:
interceptStorIni = ini_states_gcm/GFDL/interceptStor_forest_2004-12-31.map
snowCoverSWEIni  = ini_states_gcm/GFDL/snowCoverSWE_forest_2004-12-31.map
snowFreeWaterIni = ini_states_gcm/GFDL/snowFreeWater_forest_2004-12-31.map
topWaterLayerIni = ini_states_gcm/GFDL/topWaterLayer_forest_2004-12-31.map
storUppIni       = ini_states_gcm/GFDL/storUpp_forest_2004-12-31.map
storLowIni       = ini_states_gcm/GFDL/storLow_forest_2004-12-31.map
interflowIni     = ini_states_gcm/GFDL/interflow_forest_2004-12-31.map

[grasslandOptions]
name = grassland
debugWaterBalance = True

# snow module properties
snowModuleType      =  Simple
freezingT           = -0.0
degreeDayFactor     =  0.0025
snowWaterHoldingCap =  0.1
refreezingCoeff     =  0.05

# other paramater values
minTopWaterLayer = 0.0
minCropKC        = 0.2
minInterceptCap  = 0.0002

landCoverMapsNC   = None
# If NC file is not provided, we have to provide the following values:
fracVegCover      = landSurface/landCover/naturalShort/vegf_short.nc
minSoilDepthFrac  = landSurface/landCover/naturalShort/minf_short_permafrost.nc
maxSoilDepthFrac  = landSurface/landCover/naturalShort/maxf_short.nc
rootFraction1     = landSurface/landCover/naturalShort/rfrac1_short.nc
rootFraction2     = landSurface/landCover/naturalShort/rfrac2_short.nc	
maxRootDepth      = 0.5

# Parameters for the Arno's scheme:
arnoBeta = None
# If arnoBeta is defined, the soil water capacity distribution is based on this.
# If arnoBeta is NOT defined, maxSoilDepthFrac must be defined such that arnoBeta will be calculated based on maxSoilDepthFrac and minSoilDepthFrac.

cropCoefficientNC = landSurface/landCover/naturalShort/cropCoefficientGrassland.nc
interceptCapNC    = landSurface/landCover/naturalShort/interceptCapInputGrassland.nc
coverFractionNC   = landSurface/landCover/naturalShort/coverFractionInputGrassland.nc

# initial conditions:
interceptStorIni = ini_states_gcm/GFDL/interceptStor_grassland_2004-12-31.map
snowCoverSWEIni  = ini_states_gcm/GFDL/snowCoverSWE_grassland_2004-12-31.map
snowFreeWaterIni = ini_states_gcm/GFDL/snowFreeWater_grassland_2004-12-31.map
topWaterLayerIni = ini_states_gcm/GFDL/topWaterLayer_grassland_2004-12-31.map
storUppIni       = ini_states_gcm/GFDL/storUpp_grassland_2004-12-31.map
storLowIni       = ini_states_gcm/GFDL/storLow_grassland_2004-12-31.map
interflowIni     = ini_states_gcm/GFDL/interflow_grassland_2004-12-31.map

[irrPaddyOptions]
name = irrPaddy
debugWaterBalance = True

# snow module properties
snowModuleType      =  Simple
freezingT           = -0.0
degreeDayFactor     =  0.0025
snowWaterHoldingCap =  0.1
refreezingCoeff     =  0.05

landCoverMapsNC  = None
# If NC file is not provided, we have to provide the following values:
fracVegCover     = landSurface/landCover/irrPaddy/fractionPaddy.nc
minSoilDepthFrac = landSurface/landCover/irrPaddy/minf_paddy_permafrost.nc
maxSoilDepthFrac = landSurface/landCover/irrPaddy/maxf_paddy.nc
rootFraction1    = landSurface/landCover/irrPaddy/rfrac1_paddy.nc
rootFraction2    = landSurface/landCover/irrPaddy/rfrac2_paddy.nc
maxRootDepth     = 0.5

# Parameters for the Arno's scheme:
arnoBeta = None
# If arnoBeta is defined, the soil water capacity distribution is based on this.
# If arnoBeta is NOT defined, maxSoilDepthFrac must be defined such that arnoBeta will be calculated based on maxSoilDepthFrac and minSoilDepthFrac.

# other paramater values
minTopWaterLayer = 0.05
minCropKC        = 0.2
cropDeplFactor   = 0.2
minInterceptCap  = 0.0002

cropCoefficientNC = landSurface/landCover/irrPaddy/Global_CropCoefficientKc-IrrPaddy_30min.nc

# initial conditions:
interceptStorIni = ini_states_gcm/GFDL/interceptStor_irrPaddy_2004-12-31.map
snowCoverSWEIni  = ini_states_gcm/GFDL/snowCoverSWE_irrPaddy_2004-12-31.map
snowFreeWaterIni = ini_states_gcm/GFDL/snowFreeWater_irrPaddy_2004-12-31.map
topWaterLayerIni = ini_states_gcm/GFDL/topWaterLayer_irrPaddy_2004-12-31.map
storUppIni       = ini_states_gcm/GFDL/storUpp_irrPaddy_2004-12-31.map
storLowIni       = ini_states_gcm/GFDL/storLow_irrPaddy_2004-12-31.map
interflowIni     = ini_states_gcm/GFDL/interflow_irrPaddy_2004-12-31.map

[irrNonPaddyOptions]
name = irrNonPaddy
debugWaterBalance = True

# snow module properties
snowModuleType      =  Simple
freezingT           = -0.0
degreeDayFactor     =  0.0025
snowWaterHoldingCap =  0.1
refreezingCoeff     =  0.05

landCoverMapsNC  = None
# If NC file is not provided, we have to provide the following values:
fracVegCover     = landSurface/landCover/irrNonPaddy/fractionNonPaddy.nc
minSoilDepthFrac = landSurface/landCover/irrNonPaddy/minf_nonpaddy_permafrost.nc
maxSoilDepthFrac = landSurface/landCover/irrNonPaddy/maxf_nonpaddy.nc
rootFraction1    = landSurface/landCover/irrNonPaddy/rfrac1_nonpaddy.nc
rootFraction2    = landSurface/landCover/irrNonPaddy/rfrac2_nonpaddy.nc
maxRootDepth     = 1.0

# Parameters for the Arno's scheme:
arnoBeta = None
# If arnoBeta is defined, the soil water capacity distribution is based on this.
# If arnoBeta is NOT defined, maxSoilDepthFrac must be defined such that arnoBeta will be calculated based on maxSoilDepthFrac and minSoilDepthFrac.

# other paramater values
minTopWaterLayer = 0.0
minCropKC        = 0.2
minInterceptCap  = 0.0002
cropDeplFactor   = 0.5

cropCoefficientNC = landSurface/landCover/irrNonPaddy/Global_CropCoefficientKc-IrrNonPaddy_30min.nc

# initial conditions:
interceptStorIni = ini_states_gcm/GFDL/interceptStor_irrNonPaddy_2004-12-31.map
snowCoverSWEIni  = ini_states_gcm/GFDL/snowCoverSWE_irrNonPaddy_2004-12-31.map
snowFreeWaterIni = ini_states_gcm/GFDL/snowFreeWater_irrNonPaddy_2004-12-31.map
topWaterLayerIni = ini_states_gcm/GFDL/topWaterLayer_irrNonPaddy_2004-12-31.map
storUppIni       = ini_states_gcm/GFDL/storUpp_irrNonPaddy_2004-12-31.map
storLowIni       = ini_states_gcm/GFDL/storLow_irrNonPaddy_2004-12-31.map
interflowIni     = ini_states_gcm/GFDL/interflow_irrNonPaddy_2004-12-31.map

[groundwaterOptions]
debugWaterBalance = True

groundwaterPropertiesNC = groundwater/groundwaterProperties5ArcMin.nc
# The file will containspecificYield (m3.m-3), kSatAquifer (m.day-1), recessionCoeff (day-1)
#
# - minimum value for groundwater recession coefficient (day-1) 
minRecessionCoeff = 1.0e-4

# some options for constraining groundwater abstraction
limitFossilGroundWaterAbstraction      = True
estimateOfRenewableGroundwaterCapacity = 0.0
estimateOfTotalGroundwaterThickness    = groundwater/aquifer_thickness_05min.nc
# minimum and maximum total groundwater thickness 
minimumTotalGroundwaterThickness       = 100.
maximumTotalGroundwaterThickness       = None

# annual pumping capacity for each region (unit: billion cubic meter per year), should be given in a netcdf file
pumpingCapacityNC = groundwater/regional_abstraction_limit.nc

# initial conditions:
storGroundwaterIni = ini_states_gcm/GFDL/storGroundwater_2004-12-31.map
storGroundwaterFossilIni = ini_states_gcm/GFDL/storGroundwaterFossil_2004-12-31.map
#
# additional initial conditions for pumping behaviors
avgNonFossilGroundwaterAllocationLongIni  = ini_states_gcm/GFDL/avgNonFossilGroundwaterAllocationLong_2004-12-31.map
avgNonFossilGroundwaterAllocationShortIni = ini_states_gcm/GFDL/avgNonFossilGroundwaterAllocationShort_2004-12-31.map
avgTotalGroundwaterAbstractionIni         = ini_states_gcm/GFDL/avgTotalGroundwaterAbstraction_2004-12-31.map
avgTotalGroundwaterAllocationLongIni      = ini_states_gcm/GFDL/avgTotalGroundwaterAllocationLong_2004-12-31.map
avgTotalGroundwaterAllocationShortIni     = ini_states_gcm/GFDL/avgTotalGroundwaterAllocationShort_2004-12-31.map

# zonal IDs (scale) at which zonal allocation of groundwater is performed  
allocationSegmentsForGroundwater = waterUse/abstraction_zones_30min_05min.nc

[prefactorOptions] 
linear_multiplier_for_refPotET         = 1.0
linear_multiplier_for_degreeDayFactor  = 1.0
linear_multiplier_for_minSoilDepthFrac = 1.0
log_10_multiplier_for_kSat             = 0.0
linear_multiplier_for_storCap          = 1.0
log_10_multiplier_for_recessionCoeff   = 0.0

[routingOptions]
debugWaterBalance = True

routingMethod = simplifiedKinematicWave
# Options are kinematicWave, simplifiedKinematicWave and accuTravelTime

# option for maximum length of a sub time step in seconds (optional and only used if kinematicWave is used)
# - Note that too long sub time step may create water balance errors.
# - Default values: 3600 seconds for 30 arcmin ; 720 seconds for 5 arcmin
#maxiumLengthOfSubTimeStep = 3600.
maxiumLengthOfSubTimeStep = 720.

offlineRun = True
# These are only required if offlineRun is TRUE
hydrology_set_per_year = True
baseflowNC = hydro/GFDL/historical/baseflow_dailyTot_output_%4i-01-01_to_%4i-12-31.nc
interflowNC = hydro/GFDL/historical/interflowTotal_dailyTot_output_%4i-01-01_to_%4i-12-31.nc
directRunoffNC = hydro/GFDL/historical/directRunoff_dailyTot_output_%4i-01-01_to_%4i-12-31.nc

lddMap      = routing/lddsound_05min.nc
cellAreaMap = routing/cellsize05min.nc
gradient    = routing/channel_gradient.nc

# manning coefficient
manningsN   = 0.04

# constant channel depth 
constantChannelDepth = routing/bankfull_depth.nc

# constant channel width (optional)
constantChannelWidth = None
#constantChannelWidth = routing/bankfull_width.nc

# minimum channel width (optional)
minimumChannelWidth  = None
#minimumChannelWidth  = routing/bankfull_width.nc

bankfullCapacity     = None
# - If None, it will be estimated from (bankfull) channel depth (m) and width (m) 

# Option for flood plain simulation
dynamicFloodPlain = True
floodplainManningsN= 0.04

# Options for floodplain routing module
relativeElevationFiles = routing/dzRel%04d.nc
relativeElevationLevels = 0.0,0.01,0.05,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1.00

## Channel properties for flooding
maxChannelCapacity = routing/bankfull_capacity.map
#channelLength = routing/bankfull_length.map
channelDepth = routing/bankfull_depth.map
channelGradient = routing/channel_gradient.map
channelLDD = routing/lddsound_05min.nc

# Smoothing options for floodplain PDF
reductionKK = 0.5
criterionKK = 40.0

# lake and reservoir parameters
waterBodyInputNC       = routing/waterBodies5ArcMin.nc
onlyNaturalWaterBodies = False

# composite crop factors for WaterBodies: 
cropCoefficientWaterNC = routing/cropCoefficientForOpenWater.nc
minCropWaterKC         = 1.00

# number of days (timesteps) that have been performed for spinning up initial conditions in the routing module (i.e. channelStorageIni, avgDischargeLongIni, avgDischargeShortIni, etc.)
timestepsToAvgDischargeIni     = ini_states_gcm/GFDL/timestepsToAvgDischarge_2004-12-31.map
# Note that: 
# - maximum number of days (timesteps) to calculate long term average flow values (default: 5 years = 5 * 365 days = 1825)
# - maximum number of days (timesteps) to calculate short term average values (default: 1 month = 1 * 30 days = 30)

# initial conditions:
waterBodyStorageIni       = ini_states_gcm/GFDL/waterBodyStorage_2004-12-31.map
channelStorageIni         = ini_states_gcm/GFDL/channelStorage_2004-12-31.map
readAvlChannelStorageIni  = ini_states_gcm/GFDL/readAvlChannelStorage_2004-12-31.map
avgDischargeLongIni       = ini_states_gcm/GFDL/avgDischargeLong_2004-12-31.map
avgDischargeShortIni      = ini_states_gcm/GFDL/avgDischargeShort_2004-12-31.map
m2tDischargeLongIni       = ini_states_gcm/GFDL/m2tDischargeLong_2004-12-31.map
avgBaseflowLongIni        = ini_states_gcm/GFDL/avgBaseflowLong_2004-12-31.map
riverbedExchangeIni       = ini_states_gcm/GFDL/riverbedExchange_2004-12-31.map
avg_irrGrossDemandIni     = 0
avg_netLqWaterToSoilIni   = 0

avgLakeReservoirInflowShortIni = ini_states_gcm/GFDL/avgLakeReservoirInflowShort_2004-12-31.map
avgLakeReservoirOutflowLongIni = ini_states_gcm/GFDL/avgLakeReservoirOutflowLong_2004-12-31.map

# initial condition of sub-time step discharge (needed for estimating number of time steps in kinematic wave methods)
subDischargeIni      = ini_states_gcm/GFDL/subDischarge_2004-12-31.map

### Options for quality (water temperature, salinity, organic, pathogen) modelling
quality = True
calculateLoads = True

# Water quality (OPTIONAL: required only when calculateLoads is True)
PopulationNC = calc_loadings/Population_1980_2030.nc
ManWWpNC = calc_loadings/man_WWp_m3day_1980_2030.nc
UrbanFractionNC = calc_loadings/urban_fraction_1970-2010.nc
LivPopulationNC = calc_loadings/Liv_Pop_1980_2030.nc
avg_irrGrossDemandNC = hydro/GFDL/historical/irrGrossDemand_monthly_1960_2014.nc
avg_netLqWaterToSoilNC = hydro/GFDL/historical/netLqWaterToSoil_at_irrigation_monthly_1960_2014.nc

Dom_ExcrLoadNC = calc_loadings/Dom_ExcLoad.nc
Man_EfflConcNC = calc_loadings/Man_EffConc.nc
USR_EfflConcNC = calc_loadings/USR_EffConc.nc
Liv_ExcrLoadNC = calc_loadings/Liv_ExcLoad.nc
Irr_EfflConcNC = calc_loadings/Irr_EffConc.nc

WWtPathwaysNC = calc_loadings/WastewaterPathways_1980_2015.nc
#WWtRemEffs = calc_loadings/RemovalEfficiences.tbl

# Powerplant return flows
powerplantNC = calc_loadings/PowRF_1980_2030.nc

# Water quality (pre-calculated loading files)
TDSloadNC = loadings/TDSload_1980_2015.nc
BODloadNC = loadings/BODload_1980_2015.nc
FCloadNC = loadings/FCload_1980_2015.nc

# water quality initial conditions (optional):
waterTemperatureIni            = ini_states_gcm/GFDL/waterTemperature_2005-12-31.map
iceThicknessIni                = ini_states_gcm/GFDL/iceThickness_2005-12-31.map
routedTDSIni		      		     = ini_states_gcm/GFDL/routedTDS_2005-12-31.map
routedBODIni                   = ini_states_gcm/GFDL/routedBOD_2005-12-31.map
routedFCIni                    = ini_states_gcm/GFDL/routedFC_2005-12-31.map

# other constants
backgroundSalinity = loadings/Background_TDS_05min.nc
TSSmap             = loadings/TSS_2000.map

[reportingOptions]
# output files that will be written in the disk in netcdf files:
# Twload,TDSload,BODload,FCload
outDailyTotNC = discharge,channelStorage,waterTemp,TDSload,BODload,FCload,routedTDS,routedBOD,routedFC,salinity,organic,pathogen
outMonthTotNC = None
outMonthAvgNC = discharge,channelStorage,waterTemp,TDSload,BODload,FCload,routedTDS,routedBOD,routedFC,salinity,organic,pathogen
outMonthEndNC = None
outAnnuaTotNC = None
outAnnuaAvgNC = discharge,channelStorage,waterTemp,TDSload,BODload,FCload,routedTDS,routedBOD,routedFC,salinity,organic,pathogen
outAnnuaEndNC = None

# netcdf format and zlib setup
formatNetCDF = NETCDF4
zlib = True

[mergingOutputOptions]

# output variables/files that will be merged:
outDailyTotNC = None
outMonthTotNC = None
outMonthAvgNC = None
outMonthEndNC = None
outAnnuaTotNC = None
outAnnuaAvgNC = None
outAnnuaEndNC = None
outMonthMaxNC = None
outAnnuaMaxNC = None

# netcdf format and zlib setup
formatNetCDF = NETCDF4
zlib = True

delete_unmerged_pcraster_maps = False